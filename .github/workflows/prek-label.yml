name: Prek Labeler

on:
  workflow_run:
    workflows: ["Prek"]
    types:
      - completed

jobs:
  label:
    name: Update Prek Labels
    # Run on both success and failure since we now always upload artifacts
    if: github.event.workflow_run.conclusion == 'success' || github.event.workflow_run.conclusion == 'failure'
    runs-on: ubuntu-latest
    permissions:
      actions: read
      issues: write
      pull-requests: write
    steps:
      - name: Download prek result
        uses: actions/download-artifact@v4
        with:
          name: prek-result
          run-id: ${{ github.event.workflow_run.id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Update labels and comments
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs");
            const path = require("path");

            // Read the result artifact
            const resultPath = path.join(process.env.GITHUB_WORKSPACE, "prek-result.json");
            if (!fs.existsSync(resultPath)) {
              console.log("No prek-result.json found, skipping");
              return;
            }

            const result = JSON.parse(fs.readFileSync(resultPath, "utf8"));
            const pr_number = result.pr_number;
            const failed = result.failed;
            const failedSteps = result.failed_steps || [];

            if (!pr_number) {
              console.log("No PR number in result, skipping");
              return;
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = pr_number;

            // Label definitions
            const failLabel = "triage/prek-failed";
            const failColor = "d73a4a"; // red
            const failDescription = "prek checks failed (fmt/clippy/test)";

            const successLabel = "triage/prek-success";
            const successColor = "0e8a16"; // green
            const successDescription = "prek checks passed";

            const commentMarker = "<!-- gittop:prek-failed -->";
            const runUrl = `https://github.com/${owner}/${repo}/actions/runs/${{ github.event.workflow_run.id }}`;

            // Helper to ensure a label exists
            async function ensureLabel(name, color, description) {
              try {
                await github.rest.issues.createLabel({ owner, repo, name, color, description });
              } catch (error) {
                if (error.status === 422) {
                  try {
                    await github.rest.issues.updateLabel({ owner, repo, name, color, description });
                  } catch (e) {}
                }
              }
            }

            // Helper to add a label if not present
            async function addLabel(name) {
              try {
                await github.rest.issues.addLabels({ owner, repo, issue_number, labels: [name] });
              } catch (e) {
                console.log(`Failed to add label ${name}: ${e.message}`);
              }
            }

            // Helper to remove a label if present
            async function removeLabel(name) {
              try {
                await github.rest.issues.removeLabel({ owner, repo, issue_number, name });
              } catch (error) {
                if (error.status !== 404) throw error;
              }
            }

            // Ensure both labels exist
            await ensureLabel(failLabel, failColor, failDescription);
            await ensureLabel(successLabel, successColor, successDescription);

            // Get current labels
            const { data: pr } = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: pr_number
            });
            const currentLabels = pr.labels.map(l => l.name);
            const hasFailLabel = currentLabels.includes(failLabel);
            const hasSuccessLabel = currentLabels.includes(successLabel);

            // Update labels based on result
            if (failed) {
              console.log("prek failed; adding fail label, removing success label.");
              if (!hasFailLabel) await addLabel(failLabel);
              if (hasSuccessLabel) await removeLabel(successLabel);
            } else {
              console.log("prek passed; adding success label, removing fail label.");
              if (!hasSuccessLabel) await addLabel(successLabel);
              if (hasFailLabel) await removeLabel(failLabel);
            }

            // Manage comment
            const comments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number,
              per_page: 100
            });
            const existingComment = comments.find(c => (c.body || "").includes(commentMarker));

            if (failed) {
              const failedSummary = result.failed_summary || "";
              const prekOutput = result.output || "";
              
              let failureLine = failedSteps.length
                ? `**Failed hooks:** ${failedSteps.join(", ")}`
                : "**prek checks failed.**";
              
              // Build comment body with actual output
              const commentParts = [failureLine];
              
              // Add parsed failure summary if available
              if (failedSummary.trim()) {
                commentParts.push("");
                commentParts.push("**Summary:**");
                commentParts.push("```");
                commentParts.push(failedSummary.trim().substring(0, 1000));
                commentParts.push("```");
              }
              
              // Add truncated output if available
              if (prekOutput.trim()) {
                commentParts.push("");
                commentParts.push("<details>");
                commentParts.push("<summary>Full output (click to expand)</summary>");
                commentParts.push("");
                commentParts.push("```");
                // Limit to 3000 chars to avoid huge comments
                commentParts.push(prekOutput.trim().substring(0, 3000));
                commentParts.push("```");
                commentParts.push("</details>");
              }
              
              commentParts.push("");
              commentParts.push(`[View full logs](${runUrl})`);
              commentParts.push("");
              commentParts.push("Fix the issue(s) and push to rerun checks.");
              commentParts.push(commentMarker);
              
              const commentBody = commentParts.join("\n");

              if (existingComment) {
                await github.rest.issues.updateComment({
                  owner,
                  repo,
                  comment_id: existingComment.id,
                  body: commentBody
                });
              } else {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number,
                  body: commentBody
                });
              }
            } else if (existingComment) {
              try {
                await github.rest.issues.deleteComment({
                  owner,
                  repo,
                  comment_id: existingComment.id
                });
              } catch (error) {
                if (error.status !== 404) throw error;
              }
            }
